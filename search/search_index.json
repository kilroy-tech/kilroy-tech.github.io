{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#build-the-future-no-code-required","title":"[Build the Future. No Code Required.]","text":""},{"location":"index.html#about-kilroy","title":"About Kilroy","text":"<p>Kilroy empowers anyone to build, automate, launch, and share apps, AI solutions, and DeFi strategies -no code required- by making composable decentralized technology accessible for all. It's a single, double-clickable application that lets you control your apps, agents, and messages without the messy installation of command line tools and dozens of scattered pieces.</p> <p> Kilroy is a desktop-first application that integrates all of your local applications with anything else on the Internet. It provides all of the plumbing and runtime support to connect local AI agents with messaging services, cloud platforms, and remote Kilroy users. </p> <p>Based around the concept of peer-to-peer swarms, Kilroy makes building and sharing your own version of the Internet possible. Collaborate with friends over private, end-to-end encrypted communications. Connect to remote AI agents. Share your trading bots with others through online app stores. Monetize your creations with built-in markets, reputation rewards, and the ability to make your applications available to anyone you'd like.</p>"},{"location":"index.html#kilroy-uses","title":"Kilroy Uses","text":"<p>Out of the box, Kilroy comes with dozens of applications that are ready to use. Some include:</p> <ul> <li>Full-featured, drag-and-drop AI agent pipeline creation, with local and remote agents, peer-to-peer collaboration, and support for dozens of tools and services   </li> <li>Desktop automation - tight integration with deep linking to apps on your desktop or laptop</li> <li>Remote access to your Kilroy apps and agents via popular messaging apps like Telegram, Discord, and Whatsapp</li> <li>Web widgets for collecting your favorite web sites and utilities into a personal dashboard</li> </ul> <p>The options are endless, and anyone can create a new Kilroy app in minutes using the built-in visual editors, or native access to Javascript and your local  operating system if you're a power user.</p>"},{"location":"index.html#other-resources","title":"Other Resources","text":"<ul> <li>Kilroy.Tech website</li> <li>Kilroy.Tech Github</li> <li>Kilroy Wiki</li> </ul>"},{"location":"faq.html","title":"FAQ","text":""},{"location":"faq.html#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"about/about.html","title":"About","text":""},{"location":"about/about.html#about-kilroy","title":"About Kilroy","text":""},{"location":"about/contact.html","title":"Contact","text":""},{"location":"about/contact.html#contact-us","title":"Contact Us","text":""},{"location":"about/philosophy.html","title":"Philosophy","text":""},{"location":"about/philosophy.html#philosophy","title":"Philosophy","text":""},{"location":"about/team.html","title":"Team","text":""},{"location":"about/team.html#team","title":"Team","text":""},{"location":"copilot/kilroy-platform-overview.html","title":"Kilroy Platform Overview (Working Notes)","text":""},{"location":"copilot/kilroy-platform-overview.html#kilroy-platform-overview-working-notes","title":"Kilroy Platform Overview (Working Notes)","text":"<p>This document captures a cross-project architecture snapshot of the current multi-root workspace:</p> <ul> <li><code>kilroy-tech.github.io</code> \u2014 public documentation site (MkDocs Material, published to docs.kilroy.tech)</li> <li><code>kilroy.backend</code> \u2014 platform runtime (Node/Express + Electron + Docker + scheduler)</li> <li><code>kilroy.ui</code> \u2014 Vue 3 front-end app that runs on the Kilroy platform</li> </ul> <p>It is intended as a living reference for future development tasks.</p> <p>Note: This file lives in <code>docs/copilot/</code> and is intentionally NOT connected to the MkDocs nav. It contains internal working notes that should not be published.</p>"},{"location":"copilot/kilroy-platform-overview.html#what-is-kilroy-from-official-docs","title":"What is Kilroy? (from official docs)","text":"<p>Kilroy is a desktop-first, double-clickable application that lets users build, automate, launch, and share apps, AI solutions, and DeFi strategies with no code required. Key concepts from the public docs:</p> <ul> <li>Apps are self-contained JSON-driven packages (manifest + process diagrams + workflows + public assets) distributed as digitally signed zip archives, installable via the Kilroy App Store.</li> <li>Swarms are self-organizing, peer-to-peer, end-to-end encrypted communication channels. Two Kilroy instances using the same swarm name connect directly with no servers in between, no static IPs, no firewall edits.</li> <li>Pipelines compose agents (AI, WF, viewer, chat, webhook) into data-processing chains that communicate over swarms. The <code>kilroy.ai.services</code> app provides a 100% visual pipeline editor.</li> <li>Process Diagrams (PDs) define the UI layout of a running app widget \u2014 nodes, buttons, images, iframes, data views, forms \u2014 and are updated in real time via pubsub.</li> <li>Workflows are block-based or JS-scripted automations triggered by PD node actions. Each workflow step can display forms, call webhooks, manipulate data, and publish results.</li> <li>Runtime targets: macOS (Apple Silicon, Intel planned), Windows 11, Linux (Ubuntu planned), Docker (Intel/AMD, ARM, ARM7).</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#workspace-level-summary","title":"Workspace-Level Summary","text":"<ul> <li><code>kilroy.backend</code> is the runtime host and platform substrate (Node/Express + Electron-capable combined runtime + scheduler support).</li> <li><code>kilroy.backend/api/platform_data/demo/apps</code> contains app packages/projects and runtime app data, including <code>kilroy.ai.services</code> and packaged artifacts like <code>kilroy.ui.zip</code>.</li> <li><code>kilroy.ui</code> is a Vue 3 app that talks to backend HTTP endpoints and subscribes to backend pubsub channels via Faye.</li> <li><code>kilroy-tech.github.io</code> is the primary public documentation site (MkDocs Material, at <code>docs.kilroy.tech</code>).</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#kilroy-techgithubio-primary-documentation","title":"<code>kilroy-tech.github.io</code> (Primary Documentation)","text":"<p>Location: <code>/Users/cshotton/ownCloud/Documents/projects/kilroy-tech.github.io</code></p> <ul> <li>Generator: MkDocs with Material theme; config in <code>mkdocs.yml</code>.</li> <li>Published URL: <code>https://docs.kilroy.tech/</code></li> <li>CI: GitHub Actions workflow in <code>.github/workflows/ci.yml</code>.</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#content-inventory-as-of-last-scan","title":"Content inventory (as of last scan)","text":"Section File Status Home / landing <code>docs/index.md</code> Written \u2014 describes Kilroy's purpose, uses, and links Introduction <code>docs/getting-started/introduction.md</code> Written \u2014 swarms, privacy, agents &amp; apps overview Quick Start <code>docs/getting-started/quick-start.md</code> Written \u2014 platform requirements, download matrix, install steps (some sections still headings-only) Installation <code>docs/getting-started/installation.md</code> Stub \u2014 headings only Technical Overview <code>docs/developers/technical.md</code> Stub \u2014 heading only Creating Apps <code>docs/developers/apps.md</code> Partially written \u2014 manifest format, code snippets, section headings for PDs/workflows/public/build FAQ <code>docs/faq.md</code> Stub \u2014 heading only About / Philosophy / Team / Contact <code>docs/about/*.md</code> Stubs \u2014 headings only Tutorials <code>docs/tutorials/</code> Empty folder; <code>mkdocs.yml</code> references <code>tutorial1.md</code> and <code>tutorial2.md</code> that don't exist yet"},{"location":"copilot/kilroy-platform-overview.html#key-concepts-documented","title":"Key concepts documented","text":"<ul> <li>Manifest file (<code>manifest.json</code>): <code>manifestVersion</code>, <code>id</code>, <code>displayName</code>, <code>pdClasses</code> with lifecycle hooks (<code>init</code>, <code>resume</code>, <code>pause</code>, <code>stop</code>), alias naming, visibility, and multi-instance control.</li> <li>App packaging: self-contained zip archive containing manifest + process_diagrams + workflows + public folder.</li> <li>Swarm networking: peer-to-peer, end-to-end encrypted, no static IP/firewall required, self-organizing.</li> <li>Agent types listed: AI agents, WF agents, viewer agents, chat agents, webhook agents.</li> <li>Pipeline editor: drag-and-drop visual composition of agent pipelines.</li> <li>Block-based programming: Blockly-style visual workflow editor with JS escape hatch.</li> <li>Preflight/postflight pattern: <code>script.js</code> files in workflow payloads export <code>preflight(authData, wfProxy)</code> and <code>postflight(...)</code> hooks.</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#kilroybackend-architecture-notes","title":"<code>kilroy.backend</code> Architecture Notes","text":""},{"location":"copilot/kilroy-platform-overview.html#entrypoints-and-runtime-modes","title":"Entrypoints and Runtime Modes","text":"<p>Primary entrypoints in <code>api/</code>:</p> <ul> <li><code>main.js</code> (backend server)</li> <li><code>main_sched.js</code> (scheduler)</li> <li><code>main_combined.js</code> (combined backend + scheduler; package <code>main</code> points here)</li> </ul> <p><code>main_combined.js</code> initializes:</p> <ul> <li>global runtime namespace via <code>global.REBAR_NAMESPACE</code></li> <li>environment/path preflight (Node/Docker/Electron packaged/dev)</li> <li>first-run/update installation from zipped platform data</li> <li>pubsub provider and node registration/master election</li> <li>Express server + route mounting + static/public app serving</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#service-discovery-and-paths","title":"Service Discovery and Paths","text":"<ul> <li><code>api/modules/util/service_discovery.js</code> centralizes path/url resolution and env-aware behavior.</li> <li><code>api/discovery/services.js</code> defines default keys including:</li> <li><code>API_VERSION_PREFIX</code> = <code>/api/v1</code></li> <li>default pubsub service/server keys</li> <li>platform data, db, apps, workflows, and public path conventions</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#route-mounting-and-api-surface","title":"Route Mounting and API Surface","text":"<p>In <code>main_combined.js</code>, core routes mount at <code>API_VERSION_PREFIX</code>, e.g.:</p> <ul> <li><code>/api/v1/auth</code></li> <li><code>/api/v1/admin</code></li> <li><code>/api/v1/pd</code></li> <li><code>/api/v1/wf</code></li> <li>plus <code>activities</code>, <code>appservices</code>, <code>config</code>, <code>editor</code>, <code>panel</code>, etc.</li> </ul> <p>Additionally:</p> <ul> <li><code>/apps</code> serves app public files/folders.</li> <li><code>globalAPI</code> can serve UI fallback behavior (including packaged UI behavior).</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#pubsub","title":"PubSub","text":"<ul> <li><code>api/modules/util/pubsub.js</code> abstracts pubsub provider selection (<code>faye</code>/<code>crossbar</code>), defaulting to configured provider from discovery.</li> <li><code>pubsub.Init(server)</code> is called during <code>main_combined</code> startup to wire realtime services.</li> <li>Backend admin broadcasts are published on <code>admin_broadcast</code> channel (used by UI).</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#platform-data-and-app-projects","title":"Platform Data and App Projects","text":"<p>Important path:</p> <ul> <li><code>api/platform_data/demo/apps</code></li> </ul> <p>Contains many Kilroy app projects and packaged zips, including:</p> <ul> <li><code>kilroy.ai.services/</code></li> <li><code>kilroy.ui.zip</code></li> <li>multiple service apps (<code>miniflux.services</code>, <code>telegram.services</code>, etc.)</li> </ul> <p>This folder is both app catalog/runtime data and packaging target in current workflows.</p>"},{"location":"copilot/kilroy-platform-overview.html#kilroyaiservices-inside-backend-platform-data","title":"<code>kilroy.ai.services</code> (inside backend platform data)","text":"<p>Location:</p> <ul> <li><code>kilroy.backend/api/platform_data/demo/apps/kilroy.ai.services</code></li> </ul> <p>Structure:</p> <ul> <li><code>manifest.json</code></li> <li><code>process_diagrams/</code></li> <li><code>workflows/</code></li> <li><code>public/</code></li> </ul> <p>Manifest confirms app identity and classes:</p> <ul> <li>app id: <code>kilroy.ai.services</code></li> <li>includes pd classes such as <code>manager</code>, <code>pipeline</code>, <code>ai_agent</code>, <code>wf_agent</code>, <code>viewer_agent</code>, <code>chat_agent</code>, <code>webhooks</code></li> <li><code>manager</code> and <code>webhooks</code> are configured <code>runOnStart: true</code></li> </ul> <p><code>public/README.md</code> describes the intended pipeline model:</p> <ul> <li>WF agents + AI agents + viewer/chat/webhook agents</li> <li>swarm-based messaging</li> <li>OpenAI-compatible endpoint integration pattern</li> </ul> <p>This app appears to function as a primary AI pipeline/agent orchestration app in the Kilroy ecosystem.</p>"},{"location":"copilot/kilroy-platform-overview.html#kilroyui-architecture-notes","title":"<code>kilroy.ui</code> Architecture Notes","text":""},{"location":"copilot/kilroy-platform-overview.html#stack-and-buildpackaging","title":"Stack and Build/Packaging","text":"<ul> <li>Vue 3 + TypeScript + Vite + Tailwind/DaisyUI.</li> <li>Runtime build scripts include <code>create-kilroy-app</code>, which packages UI output into <code>kilroy.ui.zip</code> and copies it to:</li> <li><code>../kilroy.backend/api/platform_data/demo/apps/</code></li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#backend-http-integration","title":"Backend HTTP Integration","text":"<ul> <li><code>src/utils/api.ts</code> posts JSON to <code>VITE_SERVICE_ENDPOINT</code> and injects/rotates <code>auth_token</code> via <code>window.AUTH_TOKEN</code>.</li> <li>Typical local dev endpoint script points to:</li> <li><code>http://localhost:3000/api/v1</code></li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#auth-integration","title":"Auth Integration","text":"<ul> <li><code>src/utils/auth.ts</code> uses backend auth routes:</li> <li><code>/auth/authenticate</code></li> <li><code>/auth/validate</code></li> <li><code>/auth/deauthenticate</code></li> <li><code>/auth/authFirstPD</code></li> <li><code>/auth/authAppDashboardPD</code></li> <li>Cookie-based remember-me support stores/reloads auth token (<code>rememberme</code>).</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#pubsub-integration-faye","title":"PubSub Integration (Faye)","text":"<ul> <li>Faye client URL from <code>VITE_PUBSUB_URL</code>.</li> <li>Dashboard subscribes to <code>/admin_broadcast</code> for backend status/events.</li> <li>Process Diagram component subscribes to per-diagram channel <code>/${id}</code> (with <code>-</code> converted to <code>_</code>) and reacts to <code>UPDATE_NODES</code> messages.</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#cross-project-interaction-map","title":"Cross-Project Interaction Map","text":"<p>Primary flow observed:</p> <ol> <li>Backend (<code>main_combined</code>) starts and mounts <code>/api/v1/*</code> routes and pubsub.</li> <li>UI authenticates through backend auth routes and stores rolling auth token.</li> <li>UI invokes backend process-diagram/workflow endpoints (<code>/pd/*</code>, <code>/wf/*</code>, etc.).</li> <li>Backend pushes realtime updates over pubsub channels consumed by UI via Faye.</li> <li>UI can be packaged and deployed as a Kilroy app artifact (<code>kilroy.ui.zip</code>) into backend platform data apps.</li> <li><code>kilroy.ai.services</code> runs as a backend-managed app project in platform data and participates in workflow/pipeline ecosystem used by UI and other apps.</li> </ol>"},{"location":"copilot/kilroy-platform-overview.html#current-known-gaps-caveats","title":"Current Known Gaps / Caveats","text":"<ul> <li>Some backend admin routes still contain permissive TODO logic (<code>if (true || auth_data.valid)</code> patterns) and should be treated carefully in production-hardening discussions.</li> <li>There appears to be both source-style app folders and zip artifacts in platform app storage; deployment precedence and load order should be confirmed when needed.</li> </ul>"},{"location":"copilot/kilroy-platform-overview.html#suggested-next-deep-dive-areas","title":"Suggested Next Deep-Dive Areas","text":"<p>When needed, expand this document with:</p> <ul> <li>detailed <code>platform_data/database</code> schema and lifecycle</li> <li>precise app loading/manifest precedence rules (folder vs zip)</li> <li>workflow runtime internals (<code>wfOps</code>, script cache, workflow proxy)</li> <li>explicit message schemas for pubsub channels used by <code>kilroy.ui</code> and <code>kilroy.ai.services</code></li> <li>security model for temporary/server auth flows used by first-run/dashboard</li> </ul>"},{"location":"developers/adding_wf_agents.html","title":"Adding WF_Agent Webhooks","text":""},{"location":"developers/adding_wf_agents.html#adding-a-new-wf_agent-webhook-to-kilroy-ai-services","title":"Adding a New WF_Agent Webhook to Kilroy AI Services","text":"<p>This tutorial explains how to add a new <code>wf_agent</code> type to Kilroy's AI pipeline system. A <code>wf_agent</code> is a pipeline node that appears in the pipeline editor palette and, when it receives a swarm message, calls a server-side webhook to process the message and optionally publish a result back to the pipeline.</p> <p>Adding a new <code>wf_agent</code> requires coordinated changes in three places:</p> <ol> <li>The pipeline editor palette \u2014 defines how the new agent appears in the editor and its default configuration</li> <li>The webhooks process diagram \u2014 registers the webhook trigger endpoint</li> <li>The workflow \u2014 implements the actual processing logic in JavaScript and workflow JSON</li> </ol>"},{"location":"developers/adding_wf_agents.html#overview-how-wf_agents-work","title":"Overview: How wf_agents Work","text":"<p>When a <code>wf_agent</code> receives a message on its input swarm, the Kilroy runtime optionally calls a webhook on the <code>kilroy.ai.webhooks</code> process diagram. The webhook trigger maps to a workflow, which runs on the backend. The workflow's <code>preflight</code> function in <code>script.js</code> processes the incoming message, and the result is passed back to the pipeline as a new swarm message published to the agent's output swarm (when <code>wf_publish_results</code> is true).</p> <p>The incoming message data is available to the workflow in the <code>webhook_args</code> global context variable, which contains the following standard fields:</p> Field Description <code>tagentname</code> The name of the sending agent <code>tusername</code> The username associated with the message <code>tid</code> The message transaction ID <code>tpublish</code> Whether to publish the result (boolean/string) <code>targs</code> JSON string of per-instance configuration args from the node's <code>wf_webhook_args</code> <code>args</code> Array of message objects; each has <code>text</code>, <code>type</code>, and <code>timestamp</code> <code>from</code> Agent/user the message originated from <p>The workflow builds a <code>resp</code> object containing the result and sets it in global context. A block in the workflow's <code>step_group</code> assigns <code>resp</code> to <code>x</code>, which the runtime uses as the payload to publish back to the outbound swarm.</p>"},{"location":"developers/adding_wf_agents.html#step-1-create-the-workflow","title":"Step 1: Create the Workflow","text":"<p>Workflows live under:</p> <pre><code>api/platform_data/demo/apps/kilroy.ai.services/workflows/webhooks/&lt;name&gt;/payload/\n</code></pre> <p>Each workflow folder contains exactly three files:</p> File Purpose <code>script.js</code> JavaScript preflight/postflight logic <code>json.json</code> Compiled workflow definition (executed by the workflow engine) <code>xml.xml</code> Blockly source representation (used by the visual workflow editor)"},{"location":"developers/adding_wf_agents.html#1a-scriptjs","title":"1a. script.js","text":"<p>Start by copying the template from:</p> <pre><code>api/platform_data/demo/templates/WORKFLOW_KIND/payload/script.js\n</code></pre> <p>Replace all <code>${_rebar_wfName}</code> occurrences with your workflow's full name (e.g., <code>kilroy.ai.services/webhooks/add_1</code>) and update the <code>@author</code> and <code>@copyright</code> fields.</p> <p>The <code>preflight</code> function is where your logic lives. Use <code>wfProxy.getGlobalValue(\"webhook_args\")</code> to access incoming message data, do your processing, build the standard <code>resp</code> object, then call <code>wfProxy.setGlobalValue</code> to pass values to the workflow blocks.</p> <p>A minimal preflight that transforms message text looks like this:</p> <pre><code>function preflight(authData, wfProxy) {\n    debug (\"preflight\");\n    const wha = wfProxy.getGlobalValue(\"webhook_args\");\n    const tAgentName = wha[\"tagentname\"];\n    const tUserName  = wha[\"tusername\"];\n    const tid        = wha[\"tid\"];\n    let tPublish     = wha[\"tpublish\"];\n    let data         = null;\n    let dataType     = \"text/plain\";\n\n    tPublish = tPublish === \"true\" || tPublish === \"TRUE\" || tPublish === true;\n\n    try {\n        data     = wha.args[0].text || null;\n        dataType = wha.args[0].type || \"text/plain\";\n    } catch (err) {\n        debug(`Bad data in args: ${err}`);\n        data     = null;\n        tPublish = false;\n    }\n\n    // ---- your logic here ----\n    const result = myTransform(data);\n    // -------------------------\n\n    const resp = {\n        from: tAgentName,\n        id:   tid,\n        args: [{\n            username:  tUserName,\n            text:      String(result),\n            timestamp: Date.now(),\n            type:      dataType\n        }]\n    };\n\n    wfProxy.setGlobalValue(\"tpublish\", tPublish);\n    wfProxy.setGlobalValue(\"resp\", resp);\n    return Promise.resolve({success: true});\n}\n</code></pre> <p>Note</p> <p>The only functions available on <code>wfProxy</code> are those exported by <code>api/modules/wf/workflow_proxy.js</code>. There is no <code>getWebhookArg</code> shortcut \u2014 always use <code>getGlobalValue(\"webhook_args\")</code> and extract fields from the returned object.</p>"},{"location":"developers/adding_wf_agents.html#1b-jsonjson","title":"1b. json.json","text":"<p>Start from the template at <code>api/platform_data/demo/templates/WORKFLOW_KIND/payload/json.json</code> and replace <code>${_rebar_wfName}</code>. For a standard publish-result webhook, the structure is:</p> <pre><code>{\n    \"name\": \"kilroy.ai.services/webhooks/&lt;name&gt;\",\n    \"version\": \"1\",\n    \"description\": \"...\",\n    \"isInteractive\": false,\n    \"clean_up\": true,\n    \"inputs\": [],\n    \"outputs\": [\"tpublish\"],\n    \"args\": {\"role\": \"*\"},\n    \"steps\": [\n        {\n            \"operation\": \"set_value\",\n            \"isServer\": true,\n            \"args\": {\"variable\": \"wfCleanupFlag\", \"value\": \"1\"}\n        },\n        {\n            \"operation\": \"step_group\",\n            \"isServer\": true,\n            \"args\": {\n                \"role\": \"*\",\n                \"message\": \"\",\n                \"timer\": \"24\",\n                \"isInteractive\": false,\n                \"canTerminate\": false,\n                \"success\": [\n                    {\n                        \"operation\": \"set_var_to\",\n                        \"isServer\": true,\n                        \"args\": {\n                            \"var_name\": \"x\",\n                            \"push_array_name\": null,\n                            \"field_name\": null,\n                            \"var_expr\": {\"type\": \"variable\", \"arg\": \"resp\"}\n                        }\n                    }\n                ]\n            }\n        },\n        {\"operation\": \"end\", \"isServer\": true, \"args\": null}\n    ],\n    \"externalForms\": {}\n}\n</code></pre> <p>Key points:</p> <ul> <li><code>isInteractive</code> must be <code>false</code> for a webhook \u2014 it runs entirely on the backend with no user interaction.</li> <li><code>canTerminate</code> must be <code>false</code> for the same reason.</li> <li><code>outputs: [\"tpublish\"]</code> causes the <code>tpublish</code> variable (set in preflight) to be persisted in the workflow   instance record.</li> <li>The single block in <code>step_group.success</code> assigns the <code>resp</code> object (set in preflight) to the context   variable <code>x</code>, which the runtime uses as the outbound message payload.</li> <li>If <code>script.js</code> handles all logic and only sets <code>__results__</code>, the <code>success</code> array can be empty and   <code>outputs</code> can be <code>[]</code>.</li> </ul> <p>Warning</p> <p><code>isServer: true</code> on a block means the block runs on the backend. Set it to <code>false</code> only for blocks that require frontend interaction (e.g., showing a form). All webhook workflow blocks should be <code>isServer: true</code>.</p>"},{"location":"developers/adding_wf_agents.html#1c-xmlxml","title":"1c. xml.xml","text":"<p>The <code>xml.xml</code> file is the Blockly visual-editor source. For a simple webhook that is maintained programmatically rather than via the Blockly editor, this file documents the intended structure but is not directly executed. It should match the block structure in <code>json.json</code>. Copy and adapt the XML from a similar existing webhook in <code>workflows/webhooks/</code>.</p>"},{"location":"developers/adding_wf_agents.html#step-2-register-the-webhook-in-the-process-diagram","title":"Step 2: Register the Webhook in the Process Diagram","text":"<p>Edit:</p> <pre><code>api/platform_data/demo/apps/kilroy.ai.services/process_diagrams/webhooks/diagram.json\n</code></pre> <p>Add a new node object to the <code>nodeDataArray</code>. Use a unique negative integer key that is not already in use. Set <code>loc</code> to a position near other webhook nodes (the canvas uses <code>\"x y\"</code> string coordinates):</p> <pre><code>{\n    \"category\": \"webhook\",\n    \"title\": \"&lt;name&gt;\",\n    \"rsize\": \"144 24\",\n    \"trigger_name\": \"&lt;name&gt;\",\n    \"action_workflow\": \"kilroy.ai.services/webhooks/&lt;name&gt;\",\n    \"action_workflow_id\": \"\",\n    \"action_args\": \"{}\",\n    \"action_type\": \"WORKFLOW\",\n    \"action_trigger\": \"\",\n    \"server_only\": \"true\",\n    \"dash\": [3, 2],\n    \"visible\": true,\n    \"zOrder\": 120,\n    \"key\": -47,\n    \"loc\": \"60 -60\"\n}\n</code></pre> <p>Note</p> <p><code>trigger_name</code> must exactly match the webhook name used in <code>wf_diagram_webhook</code> in the palette entry and in the workflow's <code>name</code> field (the last path segment).</p>"},{"location":"developers/adding_wf_agents.html#step-3-add-the-palette-entry","title":"Step 3: Add the Palette Entry","text":"<p>Edit:</p> <pre><code>api/platform_data/demo/apps/kilroy.ai.services/public/pipeline_editor/js/palette_defs.js\n</code></pre> <p>Add a new entry to the <code>wf_palette</code> array. The <code>wf_diagram_alias</code> is always <code>kilroy.ai.webhooks</code> (the runtime alias of the webhooks process diagram, not its template name):</p> <pre><code>{\n    category: \"wf_agent\",\n    figure: \"Rectangle\",\n    agent_name: \"&lt;name&gt;\",\n    agent_desc: \"A short description of what this agent does.\",\n    agent_display_order: 0,\n    agent_is_controller: false,\n    agent_is_controlled: false,\n    wf_agent_name : \"&lt;name&gt;\",\n    wf_username   : \"&lt;name&gt;\",\n    wf_diagram_alias   : \"kilroy.ai.webhooks\",\n    wf_diagram_webhook : \"&lt;name&gt;\",\n    wf_call_webhook    : true,\n    wf_publish_results : true,\n    wf_webhook_args    : \"{}\",\n    wf_interval_secs: 0,\n    rsize: \"140 32\",\n    angle: \"0\",\n    fill: \"#D6D6D6\",\n    opacity: 1.0,\n    stroke: \"#000000\",\n    strokeWidth: 1,\n    font: \"12px \\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif\",\n    fontStroke : \"#000000\",\n    zOrder: 100\n},\n</code></pre> <p>Key palette fields:</p> Field Description <code>wf_diagram_alias</code> Always <code>kilroy.ai.webhooks</code> for webhook-backed agents <code>wf_diagram_webhook</code> The webhook <code>trigger_name</code> to call when a message arrives <code>wf_call_webhook</code> Set to <code>true</code> to invoke the webhook on each received message <code>wf_publish_results</code> Set to <code>true</code> to automatically publish the workflow result to the output swarm <code>wf_webhook_args</code> JSON string of default per-instance configuration; users can edit this in the pipeline editor <code>agent_is_controller</code> <code>true</code> if this agent controls another agent rather than processing data <code>agent_is_controlled</code> <code>true</code> if this agent can be controlled by a controller agent"},{"location":"developers/adding_wf_agents.html#step-4-reload-and-test","title":"Step 4: Reload and Test","text":"<p>After making these three changes:</p> <ol> <li>Restart the Kilroy backend (or hot-reload if supported) so the new workflow is picked up.</li> <li>Open the pipeline editor in the Kilroy UI.</li> <li>The new agent should appear in the <code>wf_palette</code> section of the palette.</li> <li>Drag it into a pipeline, connect it to a swarm, and run the pipeline to test it.</li> </ol>"},{"location":"developers/adding_wf_agents.html#summary-checklist","title":"Summary Checklist","text":"<ul> <li>[ ] <code>workflows/webhooks/&lt;name&gt;/payload/script.js</code> \u2014 preflight logic reads <code>webhook_args</code>, builds <code>resp</code>, sets <code>tpublish</code> and <code>resp</code> via <code>setGlobalValue</code></li> <li>[ ] <code>workflows/webhooks/&lt;name&gt;/payload/json.json</code> \u2014 non-interactive, <code>outputs: [\"tpublish\"]</code>, step assigns <code>resp</code> to <code>x</code></li> <li>[ ] <code>workflows/webhooks/&lt;name&gt;/payload/xml.xml</code> \u2014 Blockly source matching json.json</li> <li>[ ] <code>process_diagrams/webhooks/diagram.json</code> \u2014 new webhook node with matching <code>trigger_name</code> and unique <code>key</code></li> <li>[ ] <code>public/pipeline_editor/js/palette_defs.js</code> \u2014 new <code>wf_agent</code> entry in <code>wf_palette</code> with correct <code>wf_diagram_alias</code> and <code>wf_diagram_webhook</code></li> </ul>"},{"location":"developers/apps.html","title":"Creating Apps","text":""},{"location":"developers/apps.html#kilroy-apps","title":"Kilroy Apps","text":"<p>Kilroy lets developers and users quickly create self-contained applications. Using Kilroy's drag-and-drop editors, users can quickly design rich, interactive interfaces that can be powered by Kilroy's dozens of built-in functions, or can be extended using standard Javascript.</p> <p>Kilroy apps differ from traditional application executables in that they are almost exclusively made up of structured JSON data objects. A fully featured Kilroy app can contain all of the user interface, server API functions, HTML, images, and other media needed to create a Web2 or Web3 application.</p> <p>Kilroy apps are completely self-contained in a digitally signed zip archive, which can be shared online through the Kilroy App store.</p>"},{"location":"developers/apps.html#parts-of-a-kilroy-app","title":"Parts of a Kilroy App","text":""},{"location":"developers/apps.html#the-app-folder","title":"The App Folder","text":""},{"location":"developers/apps.html#the-manifest-file","title":"The Manifest File","text":"<p>The manifest.json file looks like:</p> <pre><code>{\n    \"manifestVersion\": 2,\n    \"id\"            : \"kilroy.sample\",\n    \"displayName\"   : \"Kilroy Sample App\",\n    \"desc\"          : \"Sample KApp skeleton\",\n    \"version\"       : \"1.1\",\n    \"author\"        : \"Kilroy BC, LLC\",\n    \"authorInfoUrl\" : \"http://kilroy.tech\",\n    \"appInfoUrl\"    : \"/apps/kilroy.sample/info.html\",\n    \"appImageUrl\"   : \"https://kilroydao.com/wp-content/uploads/2022/04/kilroy-transparent-cropped-1.png\",\n    \"locked\"        : true,\n    \"override\"      : true,\n    \"hidden\"        : false,\n    \"pdClasses\": {\n        \"sample\"    : {\n            \"pdName\" : \"sample\",\n            \"pdAlias\": \"kilroy.sample\",\n            \"desc\"  : \"Kilroy Sample App\",\n            \"runOnStart\": true,\n            \"visible\": true,\n            \"multipleAllowed\": false,\n            \"init\"  : \"init_hook\",\n            \"resume\": \"resume_hook\",\n            \"pause\" : \"pause_hook\",\n            \"stop\"  : \"stop_hook\"\n        },\n        \"widget\"    : {\n            \"pdName\" : \"widget\",\n            \"pdAlias\": \"kilroy.sample.widget\",\n            \"desc\"  : \"Kilroy Sample App Widget\",\n            \"runOnStart\": false,\n            \"visible\": true,\n            \"multipleAllowed\": true,\n            \"init\"  : \"init_hook\",\n            \"resume\": \"resume_hook\",\n            \"pause\" : \"pause_hook\",\n            \"stop\"  : \"stop_hook\"\n        }\n    }\n}\n</code></pre> <pre><code>    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt;\n    &lt;meta name=\"description\" content=\"Description\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0\"&gt;\n</code></pre> <pre><code>function preflight(authData, wfProxy) {\n    //called before the workflow steps run\n    debug (\"preflight\");\n    return Promise.resolve({success: true});\n}\n</code></pre>"},{"location":"developers/apps.html#process-diagrams","title":"Process Diagrams","text":""},{"location":"developers/apps.html#workflows","title":"Workflows","text":""},{"location":"developers/apps.html#public-folder","title":"Public Folder","text":""},{"location":"developers/apps.html#creating-an-app","title":"Creating an App","text":""},{"location":"developers/apps.html#build-test-distribute","title":"Build, Test, Distribute","text":"<p>Prev (About Kilroy) </p>"},{"location":"developers/memory_agents.html","title":"Memory Agent Blocks","text":""},{"location":"developers/memory_agents.html#memory-agent-blocks","title":"Memory Agent Blocks","text":"<p>Kilroy AI Services includes four built-in <code>wf_agent</code> blocks for persistent memory storage. They provide a lightweight key/value-style record store backed by a per-pipeline SQLite database, accessible from any pipeline node that can send a swarm message.</p>"},{"location":"developers/memory_agents.html#overview","title":"Overview","text":"<p>Memory agents let a pipeline store, retrieve, search, and delete text-based records that persist across conversations. Each record is written to a named memory store identified by a <code>memory_id</code> path. All four blocks share a common record schema and a common configuration approach.</p>"},{"location":"developers/memory_agents.html#record-schema","title":"Record Schema","text":"<p>Every memory record has the following fields:</p> Field Type Description <code>guid</code> string Unique identifier for the record (UUID) <code>scope</code> string Logical grouping label <code>kind</code> string Record category tag (e.g. <code>\"observation\"</code>, <code>\"summary\"</code>) <code>content</code> string The stored text <code>source</code> string Provenance label (defaults to the sending agent's name) <code>tags</code> array Optional array of string tags <code>created_at</code> number Unix timestamp (ms) when the record was created <code>updated_at</code> number Unix timestamp (ms) of the last modification"},{"location":"developers/memory_agents.html#memory-id-convention","title":"Memory ID Convention","text":"<p>All four blocks require a <code>memory_id</code> in their <code>wf_webhook_args</code>. This is a relative path within the platform's memory root directory:</p> <pre><code>instances/&lt;pipeline_uid&gt;/&lt;agent_alias&gt;\n</code></pre> <p>For example: <code>\"instances/a3d8f1b2/memories\"</code>. Using the pipeline UID in the path keeps each pipeline's data isolated from other pipelines. The <code>memory_id</code> also serves as the default <code>scope</code> value for writes if no explicit <code>scope</code> is specified.</p>"},{"location":"developers/memory_agents.html#dispatch-pattern","title":"Dispatch Pattern","text":"<p>A common pipeline design is to intercept slash-commands from a chat agent using <code>regex_match</code> relay agents, which extract the command argument and re-publish it as the incoming message to the memory block. Because the memory blocks read <code>args[0].text</code> as their payload, this works without any custom scripting. See each block below for how <code>args[0].text</code> is used.</p>"},{"location":"developers/memory_agents.html#memory_write","title":"memory_write","text":""},{"location":"developers/memory_agents.html#description","title":"Description","text":"<p>Stores a text string as a new record in a memory store. Each call creates a new record with a unique <code>guid</code>; records are not deduplicated or updated \u2014 they accumulate.</p>"},{"location":"developers/memory_agents.html#use-case","title":"Use Case","text":"<p>Use <code>memory_write</code> when a pipeline agent should remember a fact, observation, or event for later recall. Typical patterns:</p> <ul> <li>A user posts <code>/write The meeting is at 3pm</code> and a <code>regex_match</code> relay extracts the payload and delivers   it to <code>memory_write</code>.</li> <li>An AI agent produces a response that should be persisted automatically before being sent to the chat.</li> </ul>"},{"location":"developers/memory_agents.html#input-from-swarm","title":"Input from Swarm","text":"Field Required Description <code>args[0].text</code> Required The text content to store as the new record <p>If <code>args[0].text</code> is empty or missing, the hook returns <code>{ \"error\": \"no content\" }</code> without writing.</p>"},{"location":"developers/memory_agents.html#output-to-swarm","title":"Output to Swarm","text":"<p>A JSON string published back to the output swarm:</p> Condition Response Success <code>{ \"guid\": \"&lt;uuid&gt;\" }</code> Failure <code>{ \"error\": \"&lt;message&gt;\" }</code>"},{"location":"developers/memory_agents.html#wf_webhook_args","title":"wf_webhook_args","text":"<p>These are set on the agent node in the pipeline editor under Webhook Args:</p> Key Type Required Default Description <code>memory_id</code> string Required \u2014 Memory store path, e.g. <code>\"instances/a3d8f1b2/memories\"</code> <code>scope</code> string Optional <code>memory_id</code> value Logical scope label for grouping records <code>kind</code> string Optional <code>\"observation\"</code> Category tag for the record <code>source</code> string Optional Agent name Provenance label stored with the record <code>tags</code> string Optional <code>\"[]\"</code> JSON array string of tags, e.g. <code>'[\"important\",\"fact\"]'</code>"},{"location":"developers/memory_agents.html#example-wf_webhook_args-json","title":"Example wf_webhook_args JSON","text":"<pre><code>{\n  \"memory_id\": \"instances/a3d8f1b2/memories\",\n  \"kind\": \"observation\",\n  \"source\": \"user\"\n}\n</code></pre>"},{"location":"developers/memory_agents.html#memory_read","title":"memory_read","text":""},{"location":"developers/memory_agents.html#description_1","title":"Description","text":"<p>Reads records from a memory store and returns them as a JSON array. Optional filters narrow results by <code>kind</code>, <code>scope</code>, or <code>source</code>. With no filters, all records are returned.</p>"},{"location":"developers/memory_agents.html#use-case_1","title":"Use Case","text":"<p>Use <code>memory_read</code> to retrieve stored memories for display, to feed context into an AI agent, or for auditing pipeline state. Typical patterns:</p> <ul> <li>A user posts <code>/read</code> to list all stored memories in a chat interface.</li> <li>An AI context-loading step fetches all records of <code>kind: \"summary\"</code> before calling the LLM.</li> </ul>"},{"location":"developers/memory_agents.html#input-from-swarm_1","title":"Input from Swarm","text":"<p>No specific payload is required. The incoming message triggers the read operation. The content of <code>args[0].text</code> is ignored.</p>"},{"location":"developers/memory_agents.html#output-to-swarm_1","title":"Output to Swarm","text":"<p>A JSON string published back to the output swarm:</p> Condition Response Success (records found) JSON array of record objects (see Record Schema above) Success (no matches) <code>[]</code> (empty array) Failure <code>{ \"error\": \"&lt;message&gt;\" }</code>"},{"location":"developers/memory_agents.html#wf_webhook_args_1","title":"wf_webhook_args","text":"Key Type Required Default Description <code>memory_id</code> string Required \u2014 Memory store path <code>kind</code> string Optional \u2014 If set, returns only records with this kind <code>scope</code> string Optional \u2014 If set, returns only records with this scope <code>source</code> string Optional \u2014 If set, returns only records with this source label"},{"location":"developers/memory_agents.html#example-wf_webhook_args-json_1","title":"Example wf_webhook_args JSON","text":"<pre><code>{\n  \"memory_id\": \"instances/a3d8f1b2/memories\"\n}\n</code></pre> <p>To filter to summaries only:</p> <pre><code>{\n  \"memory_id\": \"instances/a3d8f1b2/memories\",\n  \"kind\": \"summary\"\n}\n</code></pre>"},{"location":"developers/memory_agents.html#memory_search","title":"memory_search","text":""},{"location":"developers/memory_agents.html#description_2","title":"Description","text":"<p>Full-text search across a memory store using SQLite FTS5. The incoming message text is used as the search query. Results are returned ranked by relevance. Optional <code>kind</code> and <code>scope</code> filters are applied after the FTS match.</p>"},{"location":"developers/memory_agents.html#use-case_2","title":"Use Case","text":"<p>Use <code>memory_search</code> when you want to retrieve memory records that are semantically relevant to a user's query or a pipeline topic. Typical patterns:</p> <ul> <li>A user posts <code>/search blue sky</code> and a <code>regex_match</code> relay extracts <code>\"blue sky\"</code> and delivers it as   the message text to <code>memory_search</code>.</li> <li>A RAG (Retrieval-Augmented Generation) step searches stored knowledge before composing an LLM prompt.</li> </ul>"},{"location":"developers/memory_agents.html#input-from-swarm_2","title":"Input from Swarm","text":"Field Required Description <code>args[0].text</code> Required The search query string <p>If <code>args[0].text</code> is empty or missing, the hook returns an empty array without querying.</p>"},{"location":"developers/memory_agents.html#output-to-swarm_2","title":"Output to Swarm","text":"<p>A JSON string published back to the output swarm:</p> Condition Response Success (matches found) JSON array of record objects ordered by FTS5 relevance Success (no matches) <code>[]</code> (empty array) Failure <code>{ \"error\": \"&lt;message&gt;\" }</code>"},{"location":"developers/memory_agents.html#wf_webhook_args_2","title":"wf_webhook_args","text":"Key Type Required Default Description <code>memory_id</code> string Required \u2014 Memory store path <code>kind</code> string Optional \u2014 Post-FTS filter: include only records of this kind <code>scope</code> string Optional \u2014 Post-FTS filter: include only records with this scope <code>tags</code> string Optional \u2014 Post-FTS filter: JSON array string or comma-separated tag list; all tags must be present (AND semantics). e.g. <code>'[\"important\",\"fact\"]'</code> or <code>\"important,fact\"</code>"},{"location":"developers/memory_agents.html#example-wf_webhook_args-json_2","title":"Example wf_webhook_args JSON","text":"<pre><code>{\n  \"memory_id\": \"instances/a3d8f1b2/memories\"\n}\n</code></pre>"},{"location":"developers/memory_agents.html#memory_delete","title":"memory_delete","text":""},{"location":"developers/memory_agents.html#description_3","title":"Description","text":"<p>Deletes memory records by <code>guid</code> (single record) or <code>kind</code> (bulk deletion). If both are set, <code>guid</code> takes priority. If neither <code>guid</code> nor <code>kind</code> can be resolved, the hook returns without deleting anything.</p> <p>The <code>guid</code> may be supplied in two ways:</p> <ol> <li>Static \u2014 set <code>guid</code> in <code>wf_webhook_args</code> directly (useful when the guid is known at design time).</li> <li>Dynamic (dispatch pattern) \u2014 leave <code>guid</code> empty in <code>wf_webhook_args</code>; the hook falls back to    <code>args[0].text</code> as the guid. This allows a <code>regex_match</code> relay to extract the guid from a <code>/delete &lt;guid&gt;</code>    command and deliver it as the message payload.</li> </ol>"},{"location":"developers/memory_agents.html#use-case_3","title":"Use Case","text":"<p>Use <code>memory_delete</code> to remove a specific record by guid or to bulk-clear all records of a given kind. Typical patterns:</p> <ul> <li>A user posts <code>/delete 3f8a2c1d-...</code> and a <code>regex_match</code> relay extracts the guid and delivers it to   <code>memory_delete</code> as the message text.</li> <li>An administrative pipeline step clears all records of <code>kind: \"temp\"</code> at the end of a session.</li> </ul>"},{"location":"developers/memory_agents.html#input-from-swarm_3","title":"Input from Swarm","text":"Field Condition Description <code>args[0].text</code> Used when <code>targs.guid</code> is empty Treated as the guid to delete <p>If neither <code>targs.guid</code>, <code>args[0].text</code>, nor <code>targs.kind</code> resolves to a non-empty value, the hook returns <code>{ \"skipped\": \"no query\" }</code> without deleting anything.</p>"},{"location":"developers/memory_agents.html#output-to-swarm_3","title":"Output to Swarm","text":"<p>A JSON string published back to the output swarm:</p> Condition Response Success <code>{ \"deleted\": &lt;count&gt; }</code> where count \u2265 0 No guid or kind provided <code>{ \"skipped\": \"no query\" }</code> Failure <code>{ \"error\": \"&lt;message&gt;\" }</code>"},{"location":"developers/memory_agents.html#wf_webhook_args_3","title":"wf_webhook_args","text":"Key Type Required Default Description <code>memory_id</code> string Required \u2014 Memory store path <code>guid</code> string Optional \u2014 Delete the specific record with this guid. If empty, falls back to <code>args[0].text</code> <code>kind</code> string Optional \u2014 Bulk-delete all records with this kind (used only when guid is not resolved)"},{"location":"developers/memory_agents.html#example-wf_webhook_args-json_3","title":"Example wf_webhook_args JSON","text":"<p>To delete by guid (static, guid known at design time):</p> <pre><code>{\n  \"memory_id\": \"instances/a3d8f1b2/memories\",\n  \"guid\": \"3f8a2c1d-7e09-4b8a-a5c3-1d2f8e4b9a07\"\n}\n</code></pre> <p>To delete by kind:</p> <pre><code>{\n  \"memory_id\": \"instances/a3d8f1b2/memories\",\n  \"kind\": \"temp\"\n}\n</code></pre> <p>To use the dispatch pattern (user provides guid at runtime via <code>/delete &lt;guid&gt;</code>):</p> <pre><code>{\n  \"memory_id\": \"instances/a3d8f1b2/memories\"\n}\n</code></pre>"},{"location":"developers/memory_agents.html#building-a-memory-pipeline","title":"Building a Memory Pipeline","text":"<p>A complete slash-command memory pipeline wires the four memory blocks together with <code>regex_match</code> dispatch agents. The general pattern is:</p> <ol> <li>A <code>chat_agent</code> (User) receives all input.</li> <li>A <code>regex_filter</code> with <code>invert: true</code> on <code>^/</code> passes non-command text to an AI agent.</li> <li>Four <code>regex_match</code> agents match <code>/write</code>, <code>/read</code>, <code>/search</code>, and <code>/delete</code> respectively,    extract any argument via a capture group, and re-publish under a unique <code>wf_agent_name</code>    (e.g. <code>\"dispatch_write\"</code>).</li> <li>Each memory block sets <code>agent_from</code> to the matching dispatch agent name so it only fires    for its specific command.</li> <li>Each memory block sets <code>wf_publish_results: true</code> and publishes its JSON response to the    chat swarm so the result is visible in the conversation.</li> </ol> <p>See the <code>memory_test</code> pipeline in <code>kilroy.sandbox/pipeline editor source docs/memory_test-1.json</code> for a working editor source document that implements this pattern.</p> <p>Note</p> <p>All four memory blocks require <code>wf_publish_results</code> to be enabled on the agent node if you want the result returned to the swarm. Without it, the webhook runs but no output message is published.</p>"},{"location":"developers/technical.html","title":"Technical Overview","text":""},{"location":"developers/technical.html#technical-overview","title":"Technical Overview","text":""},{"location":"getting-started/installation.html","title":"Installation","text":""},{"location":"getting-started/installation.html#downloading-and-installing-kilroy","title":"Downloading and Installing Kilroy","text":""},{"location":"getting-started/installation.html#installation-details","title":"Installation Details","text":""},{"location":"getting-started/installation.html#updating-kilroy","title":"Updating Kilroy","text":""},{"location":"getting-started/installation.html#managing-apps","title":"Managing Apps","text":""},{"location":"getting-started/introduction.html","title":"Introduction","text":""},{"location":"getting-started/introduction.html#intro-to-kilroy","title":"Intro to Kilroy","text":""},{"location":"getting-started/introduction.html#what-is-it","title":"What is it?","text":"<p>Kilroy is a single desktop application that lets you take control of your Internet, AI agents, apps, and social interactions.  It gives you a way to combine all of these into a personalized, decentralized view that you can build and extend. Kilroy runs downloadable \"apps\" and agent \"pipelines\" to provide unique functionality that is fully customizable. There's no need for messy command line installations, or stitching together dozens of services to make it work. It runs \"out of the box\" and you use Kilroy to extend Kilroy.</p>"},{"location":"getting-started/introduction.html#privacy-and-security","title":"Privacy and Security","text":"<p>Kilroy is based on the concept of \"swarms\", which you can think of as very private, peer-to-peer chats between any number of your Kilroy apps, friends, or cloud services. Swarms are self-organizing, meaning that you don't need to have a static IP address, fixed domain name, or edit any of your firewall rules, port forwarding definitions, or other network configurations to use them. They just work. Any two Kilroy apps using the same swarm name to communicate are instantly talking with an end-to-end encrypted connection with NO servers in between.</p> <p>Your data stays local to your computer. All of your Kilroy-related keys and passwords are stored in your local operating system's secure key storage. Your identity is guaranteed, but also kept private unless you choose to share it with other Kilry users.</p> <p>Kilroy can create a completely serverless, peer-to-peer social network of friends, family, co-workers, AI agents, and apps, where you control who participates and what is shared.</p>"},{"location":"getting-started/introduction.html#your-personal-internet","title":"Your Personal Internet","text":"<p>Kilroy is whatever you make it. If you are a developer, it's a great platform for rapidly developing apps with full-featured user interfaces and access to  a powerful library of pre-built functionality. And you can always extend Kilroy using its ability to dynamically load apps, including Javascript you provide, or connect to local or remote web services.</p> <p>If you are a power user, Kilroy's drag and drop programming environments produce \"data-driven\" applications. These apps can be shared with others, uploaded to Kilroy app stores, and monetized using Kilroy's built in support for blockchain operations.</p> <p>Anyone can easily download Kilroy apps and pipelines, connect them together in new ways, and create a personal agent platform that delivers their Internet content to their desktop, phone, or any other Internet connected device or service.</p>"},{"location":"getting-started/introduction.html#agents-and-apps","title":"Agents and Apps","text":"<p>The official Kilroy app store has dozens of free apps, available to download and install in Kilroy. Some of them include:</p> <ul> <li> <p>kilroy.ai.services : a full-featured platform for developing AI-driven pipelines using a 100% visual editor. Connect your local or cloud LLMs   to tools and services provided by Kilroy, make agents that talk to and from services like Telegram and Discord, pull data from applications on   your local computer and power AI decision making, automate devices in your home. </p> </li> <li> <p>kilroy.exchanges : apps and AI tools for interacting with over 100 centralized exchanges. Automate trading strategies, manage your investments,   integrate AI into your finances.</p> </li> <li> <p>telegram.services - create your own bots for the Telegram instant messaging platform, feed data to and from local LLM agents, access your local   desktop on the go from Telegram on your mobile device.</p> </li> <li> <p>kilroy.webwidgets - build a local dashboard that shows all of your favorite Web content in a single view. Create instantly accessible views of   live data. Watch 10 YouTube streams at once. Combine web-based data with local Kilroy apps in a single view.</p> </li> <li> <p>kilroy.devtools - access to Kilroy's low code/no code editors for building Kilroy apps and pipeline tools. A block-based programming environment with   full access to Javascript internals, plus an easy-to-use interface builder makes it possible to develop and share full-featured Kilroy apps without   knowing a programming language. Power users and developers can use these tools to build custom integrations to new functions and services inside or outside   of the Kilroy application.</p> </li> </ul>"},{"location":"getting-started/quick-start.html","title":"Quick Start","text":""},{"location":"getting-started/quick-start.html#quickstart-guide","title":"Quickstart Guide","text":""},{"location":"getting-started/quick-start.html#platform-requirements","title":"Platform Requirements","text":"<p>Kilroy is a free application download for desktop and laptop computers, designed to be cross platform and portable. It runs on most desktop architectures, with applications available for the following desktop platforms:</p> <ul> <li>macOS on Apple Silicon</li> <li>macOS on Intel - coming soon</li> <li>Windows 11</li> <li>Linux (Ubuntu) - coming soon</li> </ul> <p>Kilroy is designed to be scalable and can be run in headless server environments. Docker builds are available for Intel/AMD, ARM, and ARM7, allowing it to run on anything from a Raspberry Pi to large, multi-host enterprise installations. Because of the slightly customized nature of these environments, this version is only available for Docker upon request.</p> <ul> <li>Docker and Docker Compose - available upon request</li> </ul>"},{"location":"getting-started/quick-start.html#downloading","title":"Downloading","text":"<p>Download Kilroy for your desktop:</p> O/S and CPU Download Link Signature macOS (Apple Silicon) download TBS Windows 11 (AMD/Intel) download TBS"},{"location":"getting-started/quick-start.html#installation","title":"Installation","text":"<p>Kilroy is distributed as a .zip file, .dmg disk image, or a .exe installer, depending on your O/S platform.</p>"},{"location":"getting-started/quick-start.html#macos","title":"macOS","text":"<p>Double-click the Kilroy disk image file, and in the open window, drag the Kilroy application to your Applications folder.</p>"},{"location":"getting-started/quick-start.html#windows","title":"Windows","text":"<p>If Kilroy was downloaded as a .zip file, unarchive it and run the resulting installer application. If it was downloaded as a .exe file, run the installer directly.</p>"},{"location":"getting-started/quick-start.html#running-for-the-first-time","title":"Running for the First Time","text":""},{"location":"getting-started/quick-start.html#installing-apps","title":"Installing Apps","text":""}]}